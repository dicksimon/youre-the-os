"""Skeleton for automation script


globals passed are:
`num_cpus` number of available CPUs
`num_ram_pages` number of pages that fit on RAM
`num_swap_pages` number of pages that fit on SWAP


the event type passed are one of the following:
'IO_QUEUE'
'PAGE_NEW'
'PAGE_USE'
'PAGE_SWAP'
'PAGE_FREE'
'PROC_NEW'
'PROC_CPU'
'PROC_STARV'
'PROC_WAIT_IO'
'PROC_WAIT_PAGE'
'PROC_TERM'
'PROC_KILL'
'PROC_END'

a process is identified by its PID

a memory page are identified by the owner's PID
and an index IDX inside the process
(first page is idx=0, second page is idx=1, etc...)

the game expects a callable `run_os`, that takes as argument
the list of events generated by the game objects (processes, pages, etc...)
and expects another list of action events to be returned

see `src/lib/event_manager.py` for more info on events generated

This skeleton implementation keeps a duplicate state from the game,
it gets updated with each event and then calls the scheduler function
to generate events back to the game
"""
from dataclasses import dataclass, field
from typing import List
from collections import OrderedDict
from lib import logger

#
# A copy of the game's statea
#

@dataclass
class Page:
    pid: int
    idx: int
    in_swap: bool
    in_use: bool

    @property
    def key(self):
        return self.pid, self.idx

    def __eq__(self, other: tuple[int,int]):
        return self.key == other

@dataclass
class Process:
    pid: int
    cpu: bool = False
    starvation_level: int = 1
    waiting_for_io: bool = False
    waiting_for_page: bool = False
    has_ended: bool = False
    pages: list = field(default_factory=list)

    @property
    def key(self):
        return self.pid

    def __eq__(self, other: int):
        return self.key == other

@dataclass
class IoQueue:
    io_count: int = 0




class SchedulerBase:

    ###data structures
    logger = logger.Logger()

    # map of processes
    processes: dict[int,Process] = {}
    # map of pages
    pages: dict[tuple[int,int],Page] = {}
    # number of IO events ready
    io_queue = IoQueue()
     

    #processes sorted
    starvation = OrderedDict({5:[], 4:[], 3:[], 2:[], 1:[], 0:[]})

    terminated_processes = []


    cpus_active = set()

    cpus_inactive = set()
    
    # number of CPUs being used
    used_cpus = 0

    
    #pages in use
    pages_used = set()

    #pages in ram
    pages_ram = set()
    
    #pages in swap
    pages_swap = set()
    
    ##toDo include global settings
    settings = globals();
    cpus_inactive_limit = 42 + 16
    cpus_active_limit = 16
    cpu_count = 16
    ram_limit = 16 * 4;
    swap_limit = 16 * 11
    page_count = 0
    swap_count = 0 
    ram_count = 0


    #event queue returned to the game
    _event_queue = []

    def remove_process_from_starvation_list(self,pid):
        for starvation_level in self.starvation.keys():
            if pid in self.starvation[starvation_level]:
                self.starvation[starvation_level].remove(pid)


    #base operations
    def move_page(self, pid, idx):
        """create a move page event"""
        self._event_queue.append({
            'type': 'page',
            'pid': pid,
            'idx': idx
        })

    def move_process(self, pid):
        """create a move process event"""
        self._event_queue.append({
            'type': 'process',
            'pid': pid
        })

    def do_io(self):
        """create a process io event"""
        self._event_queue.append({
            'type': 'io_queue'
        })

    # scheduler base instruction set
    def exchange_processes(self, pid_inactive, pid_active):
        ret_val = False
        if self.release_process_from_cpu(pid_inactive) & self.move_process_to_cpu(pid_active):
            ret_val = True
        else:
            pass
        return ret_val

        
    def move_process_to_cpu(self,pid):
        if len(self.cpus_active) == self.cpus_active_limit:
            ret_val = False;
        else:
            self.cpus_active.add(pid)
            if pid in self.cpus_inactive:
                self.cpus_inactive.remove(pid)
            self.move_process(pid)
            ret_val = True
        return ret_val
    
    def release_process_from_cpu(self,pid):
        if len(self.cpus_inactive) == self.cpus_inactive_limit and not self.processes[pid].has_ended:
            ret_val = False;
        else:
            if not self.processes[pid].has_ended:
                self.cpus_inactive.add(pid)
            if pid in self.cpus_active:
                self.cpus_active.remove(pid)
            self.move_process(pid)
            ret_val = True
        return ret_val
         
    def exchange_pages(self,page_swap, page_ram):
        ret_val = False
        if self.move_page_to_swap(page_swap) and self.move_page_to_ram(page_ram):
            ret_val = True
        else:
            pass
        return ret_val
    
    def move_page_to_ram(self,page):
        if len(self.pages_ram) == self.ram_limit:
            ret_val = False;
        else:
            self.pages_ram.add(page)
            if page in self.pages_swap:
                self.pages_swap.remove(page)
            self.move_page(page[0],page[1])
            ret_val = True
        return ret_val
    
    def move_page_to_swap(self,page):
        if len(self.pages_swap) == self.swap_limit:
            ret_val = False;
        else:
            self.pages_swap.add(page)
            if page in self.pages_ram:
                self.pages_ram.remove(page)
            self.move_page(page[0],page[1])
            ret_val = True
        return ret_val
        
            

    # handling of incoming events and data structures
    def _update_IO_QUEUE(self, event):
        """IO Queue has new count

        triggered when the IO count in the IO queue has changed

        event:
            .io_count: number of IO waiting to be dispatched
        """
        self.io_queue.io_count = event.io_count
        self.on_IO_QUEUE(event.io_count)

    def _update_PAGE_NEW(self, event):
        """A new memory page was created

        triggered when a process creats a new page, may be in swap

        event:
            .pid: id of the owner process
            .idx: index of page in process
            .swap: bool, if page is in swap
            .use: bool, if page is in use
        """
        key = (event.pid, event.idx);
        page = Page(event.pid, event.idx, event.swap, event.use)
        self.pages[key] = page
        self.processes[event.pid].pages.append(page)

        if event.swap:
            self.pages_swap.add(key)
        else:
            self.pages_ram.add(key)

        if event.use:
            self.pages_used.add(key)

        self.logger.create_page(key,not event.swap)
        self.on_PAGE_NEW(page)
        self.page_count += 1
        if self.page_count >= self.ram_limit + self.swap_limit:
            print("maximum page number reached")

    def _update_PAGE_USE(self, event):
        """A page 'use' flag has changed

        triggered when either a page was not is use and is now
        in use
        or the page was in use and is now _not_ in use

        this usually comes from a process being moved into or out of
        the CPU

        event:
            .pid: id of the owner process
            .idx: index of page in process
            .use: bool, if page is in use
        """
        page = (event.pid, event.idx)
    
        if event.use:
            if page not in self.pages_used:
                self.pages_used.add(page)
        else:
            if page in self.pages_used:
                self.pages_used.remove(page)
        
        self.pages[page].use = event.use
        self.on_PAGE_USE(page,event.use)
        self.logger.page_use(page, event.use)

    def _update_PAGE_SWAP(self, event):
        """A page was swapped

        this happens mostly as a response from a swap request

        event:
            .pid: id of the owner process
            .idx: index of page in process
            .swap: bool, where it is now
        """
        page = (event.pid, event.idx)
        
        
        if event.swap:
            self.pages_swap.add(page)
            if page in self.pages_ram:
                self.pages_ram.remove(page)
        else:
            self.pages_ram.add(page)
            if page in self.pages_swap:
                  self.pages_swap.remove(page)
        
        
        self.pages[page].swap = event.swap
        self.on_PAGE_SWAP(page, event.swap);
        self.logger.move_page(page,not event.swap)

    def _update_PAGE_FREE(self, event):
        """A page is freed

        this is triggered when a process is terminated

        event:
            .pid: id of the owner process
            .idx: index of page in process
        """
        
        key = (event.pid, event.idx)
        ##remove page from other datastructures
        if key in self.pages_ram:
            self.pages_ram.remove(key)
        if key in self.pages_swap:
            self.pages_swap.remove(key)
        if key in self.pages_used:
            self.pages_used.remove(key)

        page = self.pages.pop(key)
        try:
            self.processes[event.pid].pages.remove(page)
        except ValueError:
            pass

        self.logger.free_page(key)
        self.on_PAGE_FREE(page)
        self.page_count -= 1

    def _update_PROC_NEW(self, event):
        """A new process is created

        this happens mostly as the game goes on,
        the initial starvation level is 1 (it starts at 0)

        event:
            .pid: id of the process
        """
        self.processes[event.pid] = Process(event.pid)
        self.starvation[0].append(event.pid)
        self.cpus_inactive.add(event.pid)
        self.on_PROC_NEW(event.pid)
        

    def _update_PROC_CPU(self, event):
        """A process was moved into or out of a CPU

        this happens mostly as a response from a process
        move action

        event:
            .pid: id of the process
            .cpu: bool, if is in CPU or not
        """
        self.processes[event.pid].cpu = event.cpu

        if event.cpu:
            self.cpus_active.add(event.pid)
            if event.pid in self.cpus_inactive:
                self.cpus_inactive.remove(event.pid)
        else:
            self.cpus_inactive.add(event.pid)
            if event.pid in self.cpus_active:
                  self.cpus_active.remove(event.pid)

        self.on_PROC_CPU(event.pid,event.cpu)

    def _update_PROC_STARV(self, event):
        """A process' starvation level has changed

        this is either increasing because it doesn't have
        processing time,
        or the process was on the CPU

        event:
            .pid: id of the process
            .starvation_level: the new starvation level
        """

        #update starvation data_structure
        self.processes[event.pid].starvation_level = event.starvation_level
        self.remove_process_from_starvation_list(event.pid)
        self.starvation[event.starvation_level].append(event.pid)
        self.on_PROC_STARV(event.pid, event.starvation_level)

    def _update_PROC_WAIT_IO(self, event):
        """A process wait (IO) status has changed

        this happens either randomly (blocking)
        or an IO event has been processed

        event:
            .pid: id of the process
            .waiting_for_io: bool, the new waiting status
        """
        ##needed for terminated processes!?
        if event.pid in self.processes:
            self.processes[event.pid].waiting_for_io = event.waiting_for_io
        self.on_PROC_WAIT_IO(event.pid, event.waiting_for_io)

    def _update_PROC_WAIT_PAGE(self, event):
        """A process wait (for PAGE) status has changed

        this happens either because the process was scheduled
        and a memory page is in SWAP (a page can be created into SWAP)
        or it is not longer waiting

        event:
            .pid: id of the process
            .waiting_for_page: bool, the new waiting status
        """
        self.processes[event.pid].waiting_for_page = event.waiting_for_page
        self.on_PROC_WAIT_PAGE(event.pid, event.waiting_for_page)

    def _update_PROC_TERM(self, event):
        """A process was succesfully terminated

        this happens randomly when a process is in the CPU,

        after being moved from the CPU, the process will disappear

        event:
            .pid: id of the process
        """
        self.processes[event.pid].has_ended = True
        self.terminated_processes.append(event.pid)
        self.remove_process_from_starvation_list(event.pid)

        """
        proc = self.processes.get(event.pid)
        for page in proc.pages:
            if page.key in self.pages_ram:
                self.pages_ram.remove(page.key)
            if page.key in self.pages_swap:
                self.pages_swap.remove(page.key)
            if page.key in self.pages_used:
                self.pages_used.remove(page.key)
        """
        self.on_PROC_TERM(event.pid)
        
    def _update_PROC_KILL(self, event):
        """A process was killed by the user

        this happens if the starvation level is too high (level 5, 0 based)

        the process disappeared from the process list

        event:
            .pid: id of the process
        """
        proc = self.processes.get(event.pid)
        del self.processes[event.pid]
        self.remove_process_from_starvation_list(event.pid);
        
        if event.pid in self.cpus_active:
            self.cpus_active.remove(event.pid)

        if event.pid in self.cpus_inactive:
            self.cpus_inactive.remove(event.pid)


        # shouldn't need this as pages are freed before the process is killed
        
        for page in proc.pages:
            del self.pages[page.key]
            if page.key in self.pages_ram:
                self.pages_ram.remove(page.key)
            if page.key in self.pages_swap:
                self.pages_swap.remove(page.key)
            if page.key in self.pages_used:
                self.pages_used.remove(page.key)
        
        self.on_PROC_KILL(event.pid)

    def _update_PROC_END(self, event):
        """A process was terminated and was gracefully ended

        this happens when a terminated process is removed from CPU

        event:
            .pid: id of the process
        """
        proc = self.processes.pop(event.pid)
        self.used_cpus -= 1

        if event.pid in self.cpus_active:
            self.cpus_active.remove(event.pid)

        # shouldn't need this as pages are freed before the process is removed
        
        for page in proc.pages:
            del self.pages[page.key]
            if page.key in self.pages_ram:
                self.pages_ram.remove(page.key)
            if page.key in self.pages_swap:
                self.pages_swap.remove(page.key)
            if page.key in self.pages_used:
                self.pages_used.remove(page.key)
        print ("process was terminated" + "\n")
        print (event.pid)

        self.on_PROC_END(event.pid)
   
   # hook functions for schedulding algorithms
    def on_IO_QUEUE(self, io_count):
        pass
    def on_PAGE_NEW(self, page):
        pass
    def on_PAGE_USE(self, key, use):
        pass
    def on_PAGE_SWAP(self, page, swap):
        pass
    def on_PAGE_FREE(self, page):
        pass
    def on_PROC_NEW(self, pid):
        pass
    def on_PROC_CPU(self, pid, cpu):
        pass
    def on_PROC_STARV(self, pid, starvation_level):
        pass
    def on_PROC_WAIT_IO(self, pid, waiting_for_io):
        pass
    def on_PROC_WAIT_PAGE(self, pid, waiting_for_page):
        pass
    def on_PROC_KILL(self, pid):
        pass
    def on_PROC_END(self, pid):
        pass
    def on_PROC_TERM(self, pid):
        pass


    # entrypoint
    def __call__(self, events: list):
        """Entrypoint from game

        will dispatch each event to the respective handler,
        collecting action events to send back to the game,
        if a handler doesn't exist, will ignore that event.
        """
        self._event_queue.clear()
        # update the status of process/memory
        for event in events:
            handler = getattr(self, f"_update_{event.etype}", None)
            if handler is not None:
                handler(event)
        # run the scheduler
        self.schedule()
        return self._event_queue

  
    def schedule(self):
        pass